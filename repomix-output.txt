This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-12-01T23:42:12.473Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
e2e/
  canvas/
    canvas.test.ts
  demo.test.ts
src/
  lib/
    components/
      features/
        canvas/
          api-form/
            AdvancedOptionsForm.svelte
            AuthenticationForm.svelte
            CurlCommandDisplay.svelte
            HeadersForm.svelte
            QueryParamsForm.svelte
          ApiBlock.svelte
          ApiConfigForm.svelte
          Block.svelte
          BlockPallete.svelte
          Canvas.svelte
          ControlPanel.svelte
      ui/
        button/
          button.svelte
          index.ts
        dialog/
          dialog-content.svelte
          dialog-description.svelte
          dialog-footer.svelte
          dialog-header.svelte
          dialog-overlay.svelte
          dialog-portal.svelte
          dialog-title.svelte
          index.ts
        input/
          index.ts
          input.svelte
        resizable/
          index.ts
          resizable-handle.svelte
          resizable-pane-group.svelte
        sheet/
          index.ts
          sheet-content.svelte
          sheet-description.svelte
          sheet-footer.svelte
          sheet-header.svelte
          sheet-overlay.svelte
          sheet-portal.svelte
          sheet-title.svelte
        tabs/
          index.ts
          tabs-content.svelte
          tabs-list.svelte
          tabs-trigger.svelte
        textarea/
          index.ts
          textarea.svelte
    services/
      api.ts
    stores/
      api.ts
      canvas.ts
    types/
      apiBlockConfig.ts
      block.ts
      canvas.ts
    utils/
      canvas/
        blocks.ts
        draw.ts
        events.ts
        setup.ts
    i18n.ts
    index.ts
    utils.ts
  routes/
    +layout.svelte
    +page.svelte
  app.css
  app.d.ts
  app.html
  demo.spec.ts
  hooks.server.ts
  hooks.ts
.gitignore
.npmrc
.prettierignore
.prettierrc
components.json
eslint.config.js
package.json
playwright.config.ts
postcss.config.js
README.md
svelte.config.js
tailwind.config.ts
tsconfig.json
vite.config.ts

================================================================
Repository Files
================================================================

================
File: e2e/canvas/canvas.test.ts
================
/// file: e2e/canvas/canvas.test.ts
import { test, expect } from '@playwright/test';

test.describe('Canvas Component', () => {
  test.beforeEach(async ({ page }) => {
    await page.goto('/');
  });

  test('canvas element is visible', async ({ page }) => {
    const canvas = await page.locator('canvas');
    await expect(canvas).toBeVisible();
  });

  test('control panel displays initial state', async ({ page }) => {
    const controlPanel = await page.locator('div:text("Canvas Metrics")');
    await expect(controlPanel).toBeVisible();
    
    // Check initial zoom level
    const zoomText = await page.locator('text=Zoom Level: 100%');
    await expect(zoomText).toBeVisible();
  });

// TODO: I need to add these: 
/* 
 test('control panel is draggable', async ({ page }) => {
  test('canvas responds to zoom', async ({ page }) => {
  test('canvas responds to mouse drag', async ({ page }) => {
 */
});

================
File: e2e/demo.test.ts
================
import { expect, test } from '@playwright/test';

test('home page has expected h1', async ({ page }) => {
	await page.goto('/');
	await expect(page.locator('h1')).toBeVisible();
});

================
File: src/lib/components/features/canvas/api-form/AdvancedOptionsForm.svelte
================
<!-- AdvancedOptionsForm.svelte -->
<script lang="ts">
  import { Input } from '$lib/components/ui/input';
  import type { ApiBlockConfig } from '$lib/types/apiBlockConfig';

  let { formData, updateCurlCommand } = $props<{
    formData: ApiBlockConfig;
    updateCurlCommand: () => void;
  }>();
</script>

<div class="space-y-4">
  <div class="space-y-2">
    <label class="block text-sm font-medium">Response Type</label>
    <select
      bind:value={formData.responseType}
      class="w-full p-2 border rounded"
    >
      <option value="json">JSON</option>
      <option value="text">Text</option>
      <option value="blob">Blob</option>
      <option value="arraybuffer">Array Buffer</option>
    </select>
  </div>

  <div class="space-y-2">
    <label class="block text-sm font-medium">Timeout (ms)</label>
    <Input
      type="number"
      bind:value={formData.timeout}
      placeholder="30000"
    />
  </div>

  <div class="space-y-2 px-2">
    <label class="block text-sm font-medium">Retry Configuration</label>
    <div class="flex gap-2">
      <Input
        type="number"
        bind:value={formData.retryConfig.maxRetries}
        placeholder="Max Retries"
      />
      <Input
        type="number"
        bind:value={formData.retryConfig.retryDelay}
        placeholder="Retry Delay (ms)"
      />
    </div>
  </div>

  {#if formData.method !== 'GET'}
    <div class="space-y-2">
      <label class="block text-sm font-medium">Request Body</label>
      <textarea
        class="w-full p-2 border rounded"
        rows="4"
        bind:value={formData.body}
        on:input={updateCurlCommand}
        placeholder="Request body (JSON)"
      />
    </div>
  {/if}
</div>

================
File: src/lib/components/features/canvas/api-form/AuthenticationForm.svelte
================
<!-- AuthenticationForm.svelte -->
<script lang="ts">
  import { Input } from '$lib/components/ui/input';
  import type { ApiBlockConfig } from '$lib/types/apiBlockConfig';

  let { formData, authType, updateCurlCommand } = $props<{
    formData: ApiBlockConfig;
    authType: string;
    updateCurlCommand: () => void;
  }>();

  $effect(() => {
    if (!formData.authentication) {
      formData.authentication = { type: 'none' };
    }
  });
</script>

<div class="space-y-2 px-2">
  <label class="block text-sm font-medium">Authentication</label>
  <select
    bind:value={authType}
    class="w-full p-2 border rounded"
    on:change={updateCurlCommand}
  >
    <option value="none">None</option>
    <option value="basic">Basic Auth</option>
    <option value="bearer">Bearer Token</option>
    <option value="api-key">API Key</option>
  </select>

  {#if authType === 'basic'}
    <div class="space-y-2 px-2">
      <Input
        type="text"
        placeholder="Username"
        bind:value={formData.authentication.username}
        on:input={updateCurlCommand}
      />
      <Input
        type="password"
        placeholder="Password"
        bind:value={formData.authentication.password}
        on:input={updateCurlCommand}
      />
    </div>
  {:else if authType === 'bearer'}
    <Input
      type="text"
      placeholder="Bearer Token"
      bind:value={formData.authentication.token}
      on:input={updateCurlCommand}
    />
  {:else if authType === 'api-key'}
    <div class="space-y-2 px-2">
      <Input
        type="text"
        placeholder="API Key Name"
        class="px-4"
        bind:value={formData.authentication.key}
        on:input={updateCurlCommand}
      />
      <Input
        type="text"
        placeholder="API Key Value"
        bind:value={formData.authentication.value}
        on:input={updateCurlCommand}
      />
      <select
        bind:value={formData.authentication.in}
        class="w-full p-2 border rounded"
        on:change={updateCurlCommand}
      >
        <option value="header">Header</option>
        <option value="query">Query Parameter</option>
      </select>
    </div>
  {/if}
</div>

================
File: src/lib/components/features/canvas/api-form/CurlCommandDisplay.svelte
================
<!-- CurlCommandDisplay.svelte -->
<script lang="ts">
  import { Button } from '$lib/components/ui/button';
  import { Copy } from 'lucide-svelte';

  let { curlCommand } = $props<{
    curlCommand: string;
  }>();

  async function copyToClipboard() {
    try {
      await navigator.clipboard.writeText(curlCommand);
    } catch (err) {
      console.error('Failed to copy:', err);
    }
  }
</script>

{#if curlCommand}
  <div class="space-y-2 bg-gray-100 p-4 rounded">
    <div class="flex justify-between items-center mb-2">
      <label class="block text-sm font-medium">cURL Command</label>
      <Button
        variant="ghost"
        size="sm"
        on:click={copyToClipboard}
        class="hover:bg-gray-200"
      >
        <Copy class="w-4 h-4 mr-1" />
        Copy
      </Button>
    </div>
    <div class="bg-white p-3 rounded border">
      <pre class="text-sm overflow-x-auto whitespace-pre-wrap break-all">{curlCommand}</pre>
    </div>
  </div>
{/if}

================
File: src/lib/components/features/canvas/api-form/HeadersForm.svelte
================
<!-- HeadersForm.svelte -->
<script lang="ts">
  import { Button } from '$lib/components/ui/button';
  import { Input } from '$lib/components/ui/input';
  import type { ApiBlockConfig } from '$lib/types/apiBlockConfig';

  let { formData, updateCurlCommand } = $props<{
    formData: ApiBlockConfig;
    updateCurlCommand: () => void;
  }>();

  function addHeader() {
    formData = {
      ...formData,
      headers: {
        ...formData.headers,
        '': ''
      }
    };
    updateCurlCommand();
  }

  function removeHeader(key: string) {
    const { [key]: _, ...rest } = formData.headers;
    formData = {
      ...formData,
      headers: rest
    };
    updateCurlCommand();
  }
</script>

<div class="space-y-2 px-2">
  <label class="block text-sm font-medium">Headers</label>
  {#each Object.entries(formData.headers || {}) as [key, value]}
    <div class="flex gap-2">
      <Input
        type="text"
        placeholder="Header name"
        value={key}
        on:input={(e) => {
          const newHeaders = { ...formData.headers };
          delete newHeaders[key];
          newHeaders[e.currentTarget.value] = value;
          formData = { ...formData, headers: newHeaders };
          updateCurlCommand();
        }}
      />
      <Input
        type="text"
        placeholder="Header value"
        value={value}
        on:input={(e) => {
          formData = {
            ...formData,
            headers: {
              ...formData.headers,
              [key]: e.currentTarget.value
            }
          };
          updateCurlCommand();
        }}
      />
      <Button
        variant="destructive"
        size="sm"
        on:click={() => removeHeader(key)}
        type="button"
      >
        Remove
      </Button>
    </div>
  {/each}
  <Button
    variant="secondary"
    size="sm"
    on:click={addHeader}
    type="button"
  >
    Add Header
  </Button>
</div>

================
File: src/lib/components/features/canvas/api-form/QueryParamsForm.svelte
================
<!-- QueryParamsForm.svelte -->
<script lang="ts">
  import { Button } from '$lib/components/ui/button';
	import { Input } from '$lib/components/ui/input';
	import { Tabs, TabsContent, TabsList, TabsTrigger} from '$lib/components/ui/tabs';
  import { Textarea } from '$lib/components/ui/textarea';
  import type { ApiBlockConfig } from '$lib/types/apiBlockConfig';
  import { onMount, onDestroy } from 'svelte';
  import { apiStore } from '$lib/stores/api';
  import type { ApiConfig } from '$lib/stores/api';

  export let formData: ApiBlockConfig;
  export let updateCurlCommand: () => void;

  let jsonEditorContent = '';
  let jsonError = '';
  let savedApis: ApiConfig[] = [];
  let unsubscribe: () => void;
  
  // Subscribe to the API store
  onMount(() => {
    console.log('Component mounted, formData:', formData);
    unsubscribe = apiStore.subscribe(apis => {
      console.log('API store updated:', apis);
      savedApis = apis;
      loadSavedData();
    });
  });

  onDestroy(() => {
    if (unsubscribe) {
      unsubscribe();
    }
  });

  function loadSavedData() {
    if (formData.name) {
      console.log(`Loading saved data for ${formData.name}`);
      const savedApi = savedApis.find(api => api.name === formData.name);
      console.log('Found saved API:', savedApi);

      if (savedApi) {
        if (savedApi.queryParams) {
          formData = {
            ...formData,
            queryParams: savedApi.queryParams
          };
        }
        if (savedApi.body) {
          try {
            const parsedBody = JSON.parse(savedApi.body);
            formData = {
              ...formData,
              body: savedApi.body,
              requestBody: parsedBody
            };
            jsonEditorContent = JSON.stringify(parsedBody, null, 2);
          } catch (e) {
            formData = {
              ...formData,
              body: savedApi.body,
              requestBody: savedApi.body
            };
            jsonEditorContent = savedApi.body;
          }
        }
        updateCurlCommand();
      }
    }
  }

  function addQueryParam() {
    formData = {
      ...formData,
      queryParams: {
        ...formData.queryParams,
        '': ''
      }
    };
    updateCurlCommand();
    saveQueryParams();
  }

  function removeQueryParam(key: string) {
    const { [key]: _, ...rest } = formData.queryParams || {};
    formData = {
      ...formData,
      queryParams: rest
    };
    updateCurlCommand();
    saveQueryParams();
  }

  function saveQueryParams() {
    if (formData.name) {
      console.log('Saving query params:', formData.queryParams);
      const savedApi = savedApis.find(api => api.name === formData.name);
      console.log('Found saved API:', savedApi);
      if (savedApi) {
        // Update existing API
        apiStore.update(savedApi.id, {
          queryParams: formData.queryParams
        });
      } else {
        // Add new API with required fields
        apiStore.add({
          name: formData.name,
          queryParams: formData.queryParams,
          endpoint: '',
          method: 'GET',
          headers: {},
          authentication: { type: 'none' }
        });
      }
    }
  }

  function saveRequestBody() {
    console.log('Saved APIs:', JSON.stringify(savedApis, null, 2));

    if (formData.name) {
      const bodyToSave = typeof formData.requestBody === 'string' 
        ? formData.requestBody 
        : JSON.stringify(formData.requestBody);
      console.log('Saving request body:', bodyToSave);     
      formData = {
        ...formData,
        body: bodyToSave
      };
      console.log(`Saved apis for ${formData.name}`, savedApis);
      const savedApi = savedApis.find(api => api.name === formData.name);
      console.log('Found saved API:', savedApi);

      if (savedApi) {
        // Update existing API
          apiStore.update(savedApi.id, {
          body: bodyToSave
        });
      } else {
        // Add new API with required fields
        apiStore.add({
          name: formData?.name ?? "Temporary Config",
          body: bodyToSave,
          endpoint: '',
          method: 'GET',
          headers: {},
          authentication: { type: 'none' }
        });
      }
      updateCurlCommand();
    }
  }

  function updateQueryParam(oldKey: string, newKey: string, value: string) {
    const newParams = { ...formData.queryParams };
    delete newParams[oldKey];
    newParams[newKey] = value;
    formData = { ...formData, queryParams: newParams };
    updateCurlCommand();
    saveQueryParams();
  }

  function formatJson() {
    try {
      const parsed = JSON.parse(jsonEditorContent);
      jsonEditorContent = JSON.stringify(parsed, null, 2);
      jsonError = '';
      formData = {
        ...formData,
        body: JSON.stringify(parsed),
        requestBody: parsed
      };
      saveRequestBody();
      updateCurlCommand();
    } catch (e) {
      jsonError = 'Invalid JSON format';
    }
  }

  function handleTextareaChange(e: Event) {
    const content = (e.target as HTMLTextAreaElement).value;
    jsonEditorContent = content;
    try {
      const parsed = JSON.parse(content);
      jsonError = '';
      formData = {
        ...formData,
        body: content,
        requestBody: parsed
      };
    } catch (e) {
      formData = {
        ...formData,
        body: content,
        requestBody: content
      };
    }
    saveRequestBody();
    updateCurlCommand();
  }

  $: {
    if (formData.requestBody) {
      try {
        const content = typeof formData.requestBody === 'string' 
          ? formData.requestBody 
          : JSON.stringify(formData.requestBody, null, 2);
        if (content !== jsonEditorContent) {
          jsonEditorContent = content;
          formData = {
            ...formData,
            body: typeof formData.requestBody === 'string' 
              ? formData.requestBody 
              : JSON.stringify(formData.requestBody)
          };
          saveRequestBody();
        }
      } catch (e) {
        jsonEditorContent = '';
      }
    } else {
      jsonEditorContent = '';
    }
  }
</script>

<div class="space-y-4">
  <Tabs value="query"  class="w-full">
    <TabsList>
      <TabsTrigger value="query">Query Parameters</TabsTrigger>
      <TabsTrigger value="body">Request Body</TabsTrigger>
    </TabsList>

    <TabsContent value="query" class="space-y-2 px-2">
      <label class="block text-sm font-medium">Query Parameters</label>
      {#each Object.entries(formData.queryParams || {}) as [key, value]}
        <div class="flex gap-2">
          <Input
            type="text"
            placeholder="Parameter name"
            value={key}
            on:input={(e) => {
              updateQueryParam(key, e.currentTarget.value, value);
            }}
          />
          <Input
            type="text"
            placeholder="Parameter value"
            value={value}
            on:input={(e) => {
              updateQueryParam(key, key, e.currentTarget.value);
            }}
          />
          <Button
            variant="destructive"
            size="sm"
            on:click={() => removeQueryParam(key)}
            type="button"
          >
            Remove
          </Button>
        </div>
      {/each}
      <Button
        variant="secondary"
        size="sm"
        on:click={addQueryParam}
        type="button"
      >
        Add Query Parameter
      </Button>
    </TabsContent>

    <TabsContent value="body" class="space-y-2 px-2">
      <div class="space-y-2">
        <label class="block text-sm font-medium">Request Body (JSON)</label>
        <Textarea
          rows={10}
          class="font-mono"
          value={jsonEditorContent}
          on:input={handleTextareaChange}
        />
        {#if jsonError}
          <p class="text-sm text-red-500">{jsonError}</p>
        {/if}
        <Button
          variant="secondary"
          size="sm"
          on:click={formatJson}
          type="button"
        >
          Format JSON
        </Button>
      </div>
    </TabsContent>
  </Tabs>
</div>

================
File: src/lib/components/features/canvas/ApiBlock.svelte
================
<script lang="ts">
  import { onMount } from 'svelte';
  import { executeApiCall } from '$lib/services/api';
  import { Button } from '$lib/components/ui/button';
  import { Sheet, SheetHeader } from '$lib/components/ui/sheet';
  import SheetContent from '$lib/components/ui/sheet/sheet-content.svelte';
  import SheetTitle from '$lib/components/ui/sheet/sheet-title.svelte';
  import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription } from '$lib/components/ui/dialog';
  import { ResizableHandle } from '$lib/components/ui/resizable';
  import { X } from 'lucide-svelte';
  import { Loader2 } from 'lucide-svelte';
  import ApiConfigForm from './ApiConfigForm.svelte';
  import { apiStore } from '$lib/stores/api';
		import type { Block } from '$lib/types/block';
	import type { ApiBlockConfig } from '$lib/types/apiBlockConfig';

  let { 
    block, 
    onUpdate, 
    onRemove 
  } = $props<{
    block: Block;
    onUpdate: (block: Block) => void;
    onRemove: () => void;
  }>();

  let showConfigModal = $state(false);
  let showResponseDialog = $state(false);
  let isExecuting = $state(false);
  let response = $state<any>(null);
  let error = $state<string | null>(null);
  let savedApis = $state<Array<any>>([]);

  // Subscribe to the API store
  apiStore.subscribe(apis => {
    savedApis = apis;
  });

  async function handleExecute() {
    isExecuting = true;
    error = null;
    try {
      console.log(`block.config`, block.config);
      response = await executeApiCall(block.config);
      console.log(`response`, JSON.stringify(response));
      showResponseDialog = true;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'An error occurred';
      if (errorMessage.toLowerCase().includes('cors') || errorMessage.includes('cross-origin')) {
        error = "CORS Error: Unable to access the API due to browser security restrictions. We're working on fixing this issue. In the meantime, you can try using a CORS-enabled API or contact us for support.";
      } else {
        error = errorMessage;
      }
      showResponseDialog = true;
    } finally {
      isExecuting = false;
    }
  }

  function handleConfigUpdate(newConfig: ApiBlockConfig) {
    // Save to API store if it's a new configuration
    if (newConfig.name) {
      apiStore.add({
        name: newConfig.name,
        endpoint: newConfig.url,
        method: newConfig.method,
        headers: newConfig.headers,
        body: newConfig.body
      });
    }
    
    onUpdate({
      ...block,
      config: newConfig
    });
    showConfigModal = false;
  }

  function handleCloseClick(event: MouseEvent) {
    // Prevent the click from triggering canvas events
    event.preventDefault();
    event.stopPropagation();
    onRemove();
  }
</script>

<div
  class="absolute p-4 bg-white rounded-lg shadow-lg border-2 border-blue-500 min-w-[200px] min-h-[150px]"
  style="left: {block.x}px; top: {block.y}px; width: {block.width}px; height: {block.height}px;"
>
  <div class="flex flex-col h-full">
    <div class="flex justify-between items-center mb-2">
      <span class="font-bold text-sm">{block.config.method} Request</span>
      <div class="flex gap-2 items-center">
        <Button
          variant="secondary"
          size="sm"
          on:click={() => showConfigModal = true}
        >
          Configure
        </Button>
        <Button
          variant="default"
          size="sm"
          disabled={isExecuting}
          on:click={handleExecute}
        >
          {#if isExecuting}
            <Loader2 class="w-4 h-4 mr-2 animate-spin" />
            Executing...
          {:else}
            Execute
          {/if}
        </Button>
        <Button
          variant="ghost"
          size="icon"
          class="h-6 w-6"
          on:click={handleCloseClick}
        >
          <X class="h-4 w-4" />
        </Button>
      </div>
    </div>

    <div class="text-xs truncate mb-2">
      {block.config.url}
    </div>

    {#if error}
      <div class="text-red-500 text-xs mt-2">
        {error}
      </div>
    {/if}
  </div>
</div>

{#if showConfigModal}
  <Sheet  open={showConfigModal} onOpenChange={(open) => showConfigModal = open}>
    <SheetContent class="!w-[40%] !max-w-[90%]" side="right">
      <SheetHeader>
        <SheetTitle>API Configuration</SheetTitle>
      </SheetHeader>
      <ApiConfigForm
        config={block.config}
        onSubmit={handleConfigUpdate}
      />
    </SheetContent>
  </Sheet>
{/if}

<Dialog bind:open={showResponseDialog}>
  <DialogContent>
    <DialogHeader>
      <DialogTitle>{error ? 'Error' : 'API Response'}</DialogTitle>
    </DialogHeader>
    {#if error}
      <div class="p-4 bg-destructive/10 text-destructive rounded-md">
        <p class="mb-2 font-semibold">Error Message:</p>
        <p class="text-sm">{error}</p>
      </div>
    {:else if response}
      <div class="p-4 bg-muted rounded-md overflow-auto max-h-[60vh]">
        <pre class="whitespace-pre-wrap break-words">{JSON.stringify(response, null, 2)}</pre>
      </div>
    {/if}
  </DialogContent>
</Dialog>

================
File: src/lib/components/features/canvas/ApiConfigForm.svelte
================
<!-- lib/components/features/canvas/ApiConfigForm.svelte -->
<script lang="ts">
  import { Button } from '$lib/components/ui/button';
  import { Input } from '$lib/components/ui/input';
  import { Loader2 } from 'lucide-svelte';
  import { apiStore } from '$lib/stores/api';
  import type { ApiConfig } from '$lib/stores/api';
  import type { ApiBlockConfig } from '$lib/types/apiBlockConfig';
  import AuthenticationForm from './api-form/AuthenticationForm.svelte';
  import HeadersForm from './api-form/HeadersForm.svelte';

  import AdvancedOptionsForm from './api-form/AdvancedOptionsForm.svelte';
  import CurlCommandDisplay from './api-form/CurlCommandDisplay.svelte';
	import QueryParamsForm from './api-form/QueryParamsForm.svelte';

  let { config, onSubmit } = $props<{
    config: ApiBlockConfig;
    onSubmit: (config: ApiBlockConfig) => void;
  }>();
  
  let formData = $state<ApiBlockConfig>({ 
    ...config,
    timeout: config.timeout || 30000,
    retryConfig: config.retryConfig || { maxRetries: 3, retryDelay: 1000 },
    authentication: {
      type: config.authentication?.type || 'none',
      username: config.authentication?.username || '',
      password: config.authentication?.password || '',
      token: config.authentication?.token || '',
      key: config.authentication?.key || '',
      value: config.authentication?.value || '',
      in: config.authentication?.in || 'header'
    },
    responseType: config.responseType || 'json',
    body: config.body || '',
    headers: config.headers || {},
    queryParams: config.queryParams || []
  });

  let isSubmitting = $state(false);
  let savedApis = $state<ApiConfig[]>([]);
  let showAdvanced = $state(false);
  let curlCommand = $state('');
  
  // Subscribe to the API store
  apiStore.subscribe(apis => {
    savedApis = apis;
  });

  function updateCurlCommand() {
    // Convert ApiBlockConfig to ApiConfig format
    const apiConfig: ApiConfig = {
      id: crypto.randomUUID(), // Temporary ID for cURL generation
      name: formData.name || 'Temporary Config',
      endpoint: formData.url,
      method: formData.method,
      headers: formData.headers || {},
      body: formData.body,
      queryParams: formData.queryParams,
      timeout: formData.timeout,
      retryConfig: formData.retryConfig,
      authentication: formData.authentication,
      responseType: formData.responseType,
      createdAt: Date.now(),
      updatedAt: Date.now()
    };
    
    curlCommand = apiStore.generateCurl(apiConfig);
  }

  function loadSavedApi(event: Event) {
    const select = event.target as HTMLSelectElement;
    const selectedApi = savedApis.find(api => api.id === select.value);
    console.log('Loading saved API in ApiConfigForm:', selectedApi);

    if (selectedApi) {
      formData = {
        ...formData,
        name: selectedApi.name,
        url: selectedApi.endpoint,
        method: selectedApi.method,
        headers: { ...selectedApi.headers } || {},
        body: selectedApi.body || '',
        authentication: {
          type: selectedApi.authentication?.type || 'none',
          username: selectedApi.authentication?.username || '',
          password: selectedApi.authentication?.password || '',
          token: selectedApi.authentication?.token || '',
          key: selectedApi.authentication?.key || '',
          value: selectedApi.authentication?.value || '',
          in: selectedApi.authentication?.in || 'header'
        },
        timeout: selectedApi.timeout || 30000,
        retryConfig: { ...selectedApi.retryConfig } || { maxRetries: 3, retryDelay: 1000 },
        responseType: selectedApi.responseType || 'json',
        queryParams: [...(selectedApi.queryParams || [])]
      };
      updateCurlCommand();
    }
  }
  
  async function handleSubmit(event: Event) {
    event.preventDefault();
    isSubmitting = true;
    try {
      await onSubmit(formData);
    } finally {
      isSubmitting = false;
    }
  }

  let authType = $derived(formData.authentication?.type ?? 'none');

  $effect(() => {
    if (formData) {
      updateCurlCommand();
    }
  });
</script>
  
<form 
  class="space-y-4 h-full overflow-y-auto pr-4"
  on:submit|preventDefault={handleSubmit}
>
  {#if savedApis.length > 0}
    <div class="space-y-2">
      <label class="block text-sm font-medium">Load Saved API</label>
      <select
        class="w-full p-2 border rounded"
        on:change={loadSavedApi}
      >
        <option value="">Select a saved API...</option>
        {#each savedApis as api}
          <option value={api.id}>{api.name}</option>
        {/each}
      </select>
    </div>
  {/if}

  <div class="space-y-2 px-2">
    <label class="block text-sm font-medium">Name</label>
    <Input
      type="text"
      bind:value={formData.name}
      placeholder="My API Configuration"
    />
  </div>

  <div class="space-y-2 px-2">
    <label class="block text-sm font-medium">Method</label>
    <select
      bind:value={formData.method}
      class="w-full p-2 border rounded"
    >
      <option value="GET">GET</option>
      <option value="POST">POST</option>
      <option value="PUT">PUT</option>
      <option value="DELETE">DELETE</option>
      <option value="PATCH">PATCH</option>
    </select>
  </div>

  <div class="space-y-2 px-2">
    <label class="block text-sm font-medium">URL</label>
    <Input
      type="text"
      bind:value={formData.url}
      placeholder="https://api.example.com/endpoint"
    />
  </div>

  <QueryParamsForm {formData} {updateCurlCommand} />
  <HeadersForm {formData} {updateCurlCommand} />
  <AuthenticationForm {formData} {authType} {updateCurlCommand} />

  <Button
    variant="secondary"
    type="button"
    on:click={() => showAdvanced = !showAdvanced}
  >
    {showAdvanced ? 'Hide' : 'Show'} Advanced Options
  </Button>

  {#if showAdvanced}
    <AdvancedOptionsForm {formData} {updateCurlCommand} />
  {/if}

  <CurlCommandDisplay {curlCommand} />

  <div class="flex justify-end">
    <Button type="submit" disabled={isSubmitting}>
      {#if isSubmitting}
        <Loader2 class="mr-2 h-4 w-4 animate-spin" />
        <span>Saving...</span>
      {:else}
        Save Configuration
      {/if}
    </Button>
  </div>
</form>

================
File: src/lib/components/features/canvas/Block.svelte
================
<!-- lib/components/features/canvas/Block.svelte -->
<script lang="ts">
		import type { Block } from "$lib/types/block";

    
    let { id, x, y, width, height, onDragStart } = $props<Block & {
      onDragStart: (e: DragEvent) => void;
    }>();
  </script>
  
  <div
    draggable="true"
    on:dragstart={onDragStart}
    class="absolute bg-blue-500 cursor-move"
    style="left: {x}px; top: {y}px; width: {width}px; height: {height}px;"
  >
    <div class="h-full w-full" />
  </div>

================
File: src/lib/components/features/canvas/BlockPallete.svelte
================
<!-- lib/components/features/canvas/BlockPallete.svelte -->
<script lang="ts">
  import { createBlock } from '$lib/utils/canvas/blocks';
  import { canvasStore } from '$lib/stores/canvas';
  import type { Point } from '$lib/types/canvas';

  let dragState = $state({
    isDragging: false,
    draggedBlock: null as any,
    dragOffset: { x: 0, y: 0 } as Point
  });

  function handleDragStart(event: DragEvent) {
    if (!event.dataTransfer) return;
    
    event.dataTransfer.setData('text/plain', 'new-block');
    event.dataTransfer.effectAllowed = 'move';
    
    dragState.isDragging = true;
    dragState.dragOffset = {
      x: event.offsetX,
      y: event.offsetY
    };
  }

  function handleDragEnd() {
    dragState.isDragging = false;
    dragState.draggedBlock = null;
  }
</script>

<div class="flex flex-col gap-2">
  <div class="text-sm font-semibold text-gray-800">Block Palette</div>
  <div 
    class="w-32 h-16 bg-white border-2 border-dashed border-gray-300 rounded cursor-move"
    draggable="true"
    on:dragstart={handleDragStart}
    on:dragend={handleDragEnd}
  >
    <div class="flex items-center justify-center h-full text-sm text-gray-500">
      API Block
    </div>
  </div>
</div>

================
File: src/lib/components/features/canvas/Canvas.svelte
================
<script lang="ts">
  import { onMount } from 'svelte';
  import { canvasStore } from '$lib/stores/canvas';
  import { setupCanvas, resizeCanvas } from '$lib/utils/canvas/setup';
  import { drawGrid } from '$lib/utils/canvas/draw';
  import { handleWheel } from '$lib/utils/canvas/events';
  import { createBlock, updateBlockPosition, isPointInBlock } from '$lib/utils/canvas/blocks';
  import type { CanvasProps, Point } from '$lib/types/canvas';
  import ApiBlock from './ApiBlock.svelte';
	import type { Block } from '$lib/types/block';

  let canvas: HTMLCanvasElement;
  let ctx: CanvasRenderingContext2D;

  let state = $state({
    dragStartPosition: { x: 0, y: 0 } as Point,
    isDragging: false,
    dragOffset: { x: 0, y: 0 } as Point,
    isPanning: false,
    panStart: { x: 0, y: 0 } as Point
  });
  
  let { width, height } = $props<CanvasProps>();

  function getCanvasPoint(clientX: number, clientY: number): Point {
    const rect = canvas.getBoundingClientRect();
    return {
      x: (clientX - rect.left - $canvasStore.offsetX) / $canvasStore.scale,
      y: (clientY - rect.top - $canvasStore.offsetY) / $canvasStore.scale
    };
  }

  function handleBlockDragStart(event: MouseEvent) {
    if (!(event.target as HTMLElement).closest('.api-block')) {
      const point = getCanvasPoint(event.clientX, event.clientY);
      const clickedBlock = $canvasStore.blocks.find(block => isPointInBlock(point, block));
      
      if (clickedBlock) {
        event.preventDefault();
        event.stopPropagation();
        
        state.dragOffset = {
          x: point.x - clickedBlock.x,
          y: point.y - clickedBlock.y
        };
        
        canvasStore.update(s => ({
          ...s,
          selectedBlockId: clickedBlock.id,
          draggingBlock: true
        }));
        
        state.dragStartPosition = point;
        state.isDragging = true;
        
        canvas.classList.add('dragging');
      } else {
        // Start panning if not clicking on a block
        state.isPanning = true;
        state.panStart = {
          x: event.clientX - $canvasStore.offsetX,
          y: event.clientY - $canvasStore.offsetY
        };
      }
    }
  }

  function handleBlockDragMove(event: MouseEvent) {
    if (state.isDragging && $canvasStore.selectedBlockId) {
      const currentPoint = getCanvasPoint(event.clientX, event.clientY);
      
      const newPosition = {
        x: currentPoint.x - state.dragOffset.x,
        y: currentPoint.y - state.dragOffset.y
      };

      requestAnimationFrame(() => {
        canvasStore.update(s => ({
          ...s,
          blocks: s.blocks.map(block => 
            block.id === s.selectedBlockId
              ? updateBlockPosition(block, newPosition)
              : block
          )
        }));
      });
    } else if (state.isPanning) {
      // Handle panning
      const newOffsetX = event.clientX - state.panStart.x;
      const newOffsetY = event.clientY - state.panStart.y;

      canvasStore.update(s => ({
        ...s,
        offsetX: newOffsetX,
        offsetY: newOffsetY
      }));
    }
  }

  function handleBlockDragEnd(event: MouseEvent) {
    if (state.isDragging) {
      state.isDragging = false;
      canvasStore.update(s => ({
        ...s,
        selectedBlockId: null,
        draggingBlock: false
      }));
      
      canvas.classList.remove('dragging');
    }
    
    state.isPanning = false;
  }

  function handleCanvasClick(event: MouseEvent) {
    if (!(event.target as HTMLElement).closest('.api-block')) {
      if (event.altKey) {
        const point = getCanvasPoint(event.clientX, event.clientY);
        const newBlock = createBlock(point);
        
        canvasStore.update(s => ({
          ...s,
          blocks: [...s.blocks, newBlock]
        }));
      }
    }
  }

  function removeBlock(blockId: string) {
    canvasStore.update(s => ({
      ...s,
      blocks: s.blocks.filter(block => block.id !== blockId)
    }));
  }

  function render() {
    if (!ctx) return;
    
    ctx.save();
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.restore();
    
    ctx.save();
    ctx.translate($canvasStore.offsetX, $canvasStore.offsetY);
    ctx.scale($canvasStore.scale, $canvasStore.scale);
    
    drawGrid(ctx, canvas, $canvasStore.scale, $canvasStore.offsetX, $canvasStore.offsetY);
    
    ctx.restore();
  }

  onMount(() => {
    ctx = setupCanvas(canvas);
    resizeCanvas(canvas);
    render();

    const handleWindowMouseUp = (event: MouseEvent) => {
      handleBlockDragEnd(event);
    };

    window.addEventListener('mouseup', handleWindowMouseUp);
    window.addEventListener('resize', () => {
      resizeCanvas(canvas);
      render();
    });

    return () => {
      window.removeEventListener('mouseup', handleWindowMouseUp);
    };
  });

  $effect(() => {
    render();
  });

  function handleBlockUpdate(updatedBlock: Block) {
    canvasStore.update(state => ({
      ...state,
      blocks: state.blocks.map(block => 
        block.id === updatedBlock.id ? updatedBlock : block
      )
    }));
  }

  function handleDragOver(event: DragEvent) {
    event.preventDefault();
    event.dataTransfer!.dropEffect = 'move';
  }

  function handleDrop(event: DragEvent) {
    event.preventDefault();
    const data = event.dataTransfer?.getData('text/plain');
    if (data !== 'new-block') return;
    
    const point = getCanvasPoint(event.clientX, event.clientY);
    const newBlock = createBlock(point);
    
    canvasStore.update(s => ({
      ...s,
      blocks: [...s.blocks, newBlock]
    }));
  }
</script>

<div class="relative w-full h-full">
  <canvas
    bind:this={canvas}
    on:mousedown={handleBlockDragStart}
    on:mousemove={handleBlockDragMove}
    on:mouseup={handleBlockDragEnd}
    on:mouseleave={handleBlockDragEnd}
    on:click={handleCanvasClick}
    on:wheel={(e) => {
      e.preventDefault();
      canvasStore.update(s => ({ ...s, ...handleWheel(e, $canvasStore) }));
    }}
    on:dragover={handleDragOver}
    on:drop={handleDrop}
    class="absolute inset-0 cursor-grab active:cursor-grabbing"
  />

  <div 
    class="absolute inset-0"
    style="transform: translate({$canvasStore.offsetX}px, {$canvasStore.offsetY}px) scale({$canvasStore.scale})"
  >
    {#each $canvasStore.blocks as block (block.id)}
      <ApiBlock
        {block}
        onUpdate={handleBlockUpdate}
        onRemove={() => removeBlock(block.id)}
        class="api-block"
      />
    {/each}
  </div>
</div>

<div class="fixed bottom-4 right-4 p-4 bg-white/90 rounded-lg shadow-lg">
  <p class="text-sm text-gray-600">Press Alt + Click to create a new block</p>
  <p class="text-sm text-gray-600">Click and drag empty space to pan</p>
</div>

================
File: src/lib/components/features/canvas/ControlPanel.svelte
================
<!-- lib/components/features/canvas/ControlPanel.svelte -->
<script lang="ts">
  import { canvasStore } from '$lib/stores/canvas';
  import BlockPallete from "./BlockPallete.svelte";
  
  let { mouseX, mouseY, scale, offsetX, offsetY } = $props();
  
  let state = $state({
    isDragging: false,
    panelX: 20,
    panelY: 20,
    dragStartX: 0,
    dragStartY: 0
  });

  function startDrag(event: MouseEvent) {
    if (event.target instanceof HTMLButtonElement) return;
    state.isDragging = true;
    state.dragStartX = event.clientX - state.panelX;
    state.dragStartY = event.clientY - state.panelY;
  }

  function onDrag(event: MouseEvent) {
    if (!state.isDragging) return;
    state.panelX = event.clientX - state.dragStartX;
    state.panelY = event.clientY - state.dragStartY;
  }

  function stopDrag() {
    state.isDragging = false;
  }

  function resetCanvas() {
    canvasStore.update(state => ({
      ...state,
      offsetX: 0,
      offsetY: 0,
      scale: 1
    }));
  }
</script>

<div
  class="fixed flex flex-col gap-4 rounded-lg bg-white/90 p-4 shadow-lg backdrop-blur-sm"
  style="left: {state.panelX}px; top: {state.panelY}px; user-select: none;"
  onmousedown={startDrag}
  onmousemove={onDrag}
  onmouseup={stopDrag}
  onmouseleave={stopDrag}
>
  <div class="flex items-center justify-between">
    <div class="text-sm font-semibold text-gray-800">Canvas Metrics</div>
    <button 
      class="rounded bg-blue-500 px-2 py-1 text-xs text-white hover:bg-blue-600"
      onclick={resetCanvas}
    >
      Reset View
    </button>
  </div>
  
  <div class="space-y-1 text-sm text-gray-600">
    <div class="flex justify-between gap-4">
      <span>Mouse Position:</span>
      <span class="font-mono">X: {mouseX.toFixed(0)}, Y: {mouseY.toFixed(0)}</span>
    </div>
    <div class="flex justify-between gap-4">
      <span>Canvas Offset:</span>
      <span class="font-mono">X: {offsetX.toFixed(0)}, Y: {offsetY.toFixed(0)}</span>
    </div>
    <div class="flex justify-between gap-4">
      <span>Zoom Level:</span>
      <span class="font-mono">{(scale * 100).toFixed(0)}%</span>
    </div>
  </div>
  <div class="h-px bg-gray-200" />
  <BlockPallete />
</div>

================
File: src/lib/components/ui/button/button.svelte
================
<script lang="ts">
	import { Button as ButtonPrimitive } from "bits-ui";
	import { type Events, type Props, buttonVariants } from "./index.js";
	import { cn } from "$lib/utils.js";

	type $$Props = Props;
	type $$Events = Events;

	let className: $$Props["class"] = undefined;
	export let variant: $$Props["variant"] = "default";
	export let size: $$Props["size"] = "default";
	export let builders: $$Props["builders"] = [];
	export { className as class };
</script>

<ButtonPrimitive.Root
	{builders}
	class={cn(buttonVariants({ variant, size, className }))}
	type="button"
	{...$$restProps}
	on:click
	on:keydown
>
	<slot />
</ButtonPrimitive.Root>

================
File: src/lib/components/ui/button/index.ts
================
import { type VariantProps, tv } from "tailwind-variants";
import type { Button as ButtonPrimitive } from "bits-ui";
import Root from "./button.svelte";

const buttonVariants = tv({
	base: "ring-offset-background focus-visible:ring-ring inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
	variants: {
		variant: {
			default: "bg-primary text-primary-foreground hover:bg-primary/90",
			destructive: "bg-destructive text-destructive-foreground hover:bg-destructive/90",
			outline:
				"border-input bg-background hover:bg-accent hover:text-accent-foreground border",
			secondary: "bg-secondary text-secondary-foreground hover:bg-secondary/80",
			ghost: "hover:bg-accent hover:text-accent-foreground",
			link: "text-primary underline-offset-4 hover:underline",
		},
		size: {
			default: "h-10 px-4 py-2",
			sm: "h-9 rounded-md px-3",
			lg: "h-11 rounded-md px-8",
			icon: "h-10 w-10",
		},
	},
	defaultVariants: {
		variant: "default",
		size: "default",
	},
});

type Variant = VariantProps<typeof buttonVariants>["variant"];
type Size = VariantProps<typeof buttonVariants>["size"];

type Props = ButtonPrimitive.Props & {
	variant?: Variant;
	size?: Size;
};

type Events = ButtonPrimitive.Events;

export {
	Root,
	type Props,
	type Events,
	//
	Root as Button,
	type Props as ButtonProps,
	type Events as ButtonEvents,
	buttonVariants,
};

================
File: src/lib/components/ui/dialog/dialog-content.svelte
================
<script lang="ts">
	import { Dialog as DialogPrimitive } from "bits-ui";
	import X from "lucide-svelte/icons/x";
	import * as Dialog from "./index.js";
	import { cn, flyAndScale } from "$lib/utils.js";

	type $$Props = DialogPrimitive.ContentProps;

	let className: $$Props["class"] = undefined;
	export let transition: $$Props["transition"] = flyAndScale;
	export let transitionConfig: $$Props["transitionConfig"] = {
		duration: 200,
	};
	export { className as class };
</script>

<Dialog.Portal>
	<Dialog.Overlay />
	<DialogPrimitive.Content
		{transition}
		{transitionConfig}
		class={cn(
			"bg-background fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border p-6 shadow-lg sm:rounded-lg md:w-full",
			className
		)}
		{...$$restProps}
	>
		<slot />
		<DialogPrimitive.Close
			class="ring-offset-background focus:ring-ring data-[state=open]:bg-accent data-[state=open]:text-muted-foreground absolute right-4 top-4 rounded-sm opacity-70 transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-offset-2 disabled:pointer-events-none"
		>
			<X class="h-4 w-4" />
			<span class="sr-only">Close</span>
		</DialogPrimitive.Close>
	</DialogPrimitive.Content>
</Dialog.Portal>

================
File: src/lib/components/ui/dialog/dialog-description.svelte
================
<script lang="ts">
	import { Dialog as DialogPrimitive } from "bits-ui";
	import { cn } from "$lib/utils.js";

	type $$Props = DialogPrimitive.DescriptionProps;

	let className: $$Props["class"] = undefined;
	export { className as class };
</script>

<DialogPrimitive.Description
	class={cn("text-muted-foreground text-sm", className)}
	{...$$restProps}
>
	<slot />
</DialogPrimitive.Description>

================
File: src/lib/components/ui/dialog/dialog-footer.svelte
================
<script lang="ts">
	import type { HTMLAttributes } from "svelte/elements";
	import { cn } from "$lib/utils.js";

	type $$Props = HTMLAttributes<HTMLDivElement>;

	let className: $$Props["class"] = undefined;
	export { className as class };
</script>

<div
	class={cn("flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2", className)}
	{...$$restProps}
>
	<slot />
</div>

================
File: src/lib/components/ui/dialog/dialog-header.svelte
================
<script lang="ts">
	import type { HTMLAttributes } from "svelte/elements";
	import { cn } from "$lib/utils.js";

	type $$Props = HTMLAttributes<HTMLDivElement>;

	let className: $$Props["class"] = undefined;
	export { className as class };
</script>

<div class={cn("flex flex-col space-y-1.5 text-center sm:text-left", className)} {...$$restProps}>
	<slot />
</div>

================
File: src/lib/components/ui/dialog/dialog-overlay.svelte
================
<script lang="ts">
	import { Dialog as DialogPrimitive } from "bits-ui";
	import { fade } from "svelte/transition";
	import { cn } from "$lib/utils.js";

	type $$Props = DialogPrimitive.OverlayProps;

	let className: $$Props["class"] = undefined;
	export let transition: $$Props["transition"] = fade;
	export let transitionConfig: $$Props["transitionConfig"] = {
		duration: 150,
	};
	export { className as class };
</script>

<DialogPrimitive.Overlay
	{transition}
	{transitionConfig}
	class={cn("bg-background/80 fixed inset-0 z-50 backdrop-blur-sm", className)}
	{...$$restProps}
/>

================
File: src/lib/components/ui/dialog/dialog-portal.svelte
================
<script lang="ts">
	import { Dialog as DialogPrimitive } from "bits-ui";
	type $$Props = DialogPrimitive.PortalProps;
</script>

<DialogPrimitive.Portal {...$$restProps}>
	<slot />
</DialogPrimitive.Portal>

================
File: src/lib/components/ui/dialog/dialog-title.svelte
================
<script lang="ts">
	import { Dialog as DialogPrimitive } from "bits-ui";
	import { cn } from "$lib/utils.js";

	type $$Props = DialogPrimitive.TitleProps;

	let className: $$Props["class"] = undefined;
	export { className as class };
</script>

<DialogPrimitive.Title
	class={cn("text-lg font-semibold leading-none tracking-tight", className)}
	{...$$restProps}
>
	<slot />
</DialogPrimitive.Title>

================
File: src/lib/components/ui/dialog/index.ts
================
import { Dialog as DialogPrimitive } from "bits-ui";

import Title from "./dialog-title.svelte";
import Portal from "./dialog-portal.svelte";
import Footer from "./dialog-footer.svelte";
import Header from "./dialog-header.svelte";
import Overlay from "./dialog-overlay.svelte";
import Content from "./dialog-content.svelte";
import Description from "./dialog-description.svelte";

const Root = DialogPrimitive.Root;
const Trigger = DialogPrimitive.Trigger;
const Close = DialogPrimitive.Close;

export {
	Root,
	Title,
	Portal,
	Footer,
	Header,
	Trigger,
	Overlay,
	Content,
	Description,
	Close,
	//
	Root as Dialog,
	Title as DialogTitle,
	Portal as DialogPortal,
	Footer as DialogFooter,
	Header as DialogHeader,
	Trigger as DialogTrigger,
	Overlay as DialogOverlay,
	Content as DialogContent,
	Description as DialogDescription,
	Close as DialogClose,
};

================
File: src/lib/components/ui/input/index.ts
================
import Root from "./input.svelte";

export type FormInputEvent<T extends Event = Event> = T & {
	currentTarget: EventTarget & HTMLInputElement;
};
export type InputEvents = {
	blur: FormInputEvent<FocusEvent>;
	change: FormInputEvent<Event>;
	click: FormInputEvent<MouseEvent>;
	focus: FormInputEvent<FocusEvent>;
	focusin: FormInputEvent<FocusEvent>;
	focusout: FormInputEvent<FocusEvent>;
	keydown: FormInputEvent<KeyboardEvent>;
	keypress: FormInputEvent<KeyboardEvent>;
	keyup: FormInputEvent<KeyboardEvent>;
	mouseover: FormInputEvent<MouseEvent>;
	mouseenter: FormInputEvent<MouseEvent>;
	mouseleave: FormInputEvent<MouseEvent>;
	mousemove: FormInputEvent<MouseEvent>;
	paste: FormInputEvent<ClipboardEvent>;
	input: FormInputEvent<InputEvent>;
	wheel: FormInputEvent<WheelEvent>;
};

export {
	Root,
	//
	Root as Input,
};

================
File: src/lib/components/ui/input/input.svelte
================
<script lang="ts">
	import type { HTMLInputAttributes } from "svelte/elements";
	import type { InputEvents } from "./index.js";
	import { cn } from "$lib/utils.js";

	type $$Props = HTMLInputAttributes;
	type $$Events = InputEvents;

	let className: $$Props["class"] = undefined;
	export let value: $$Props["value"] = undefined;
	export { className as class };

	// Workaround for https://github.com/sveltejs/svelte/issues/9305
	// Fixed in Svelte 5, but not backported to 4.x.
	export let readonly: $$Props["readonly"] = undefined;
</script>

<input
	class={cn(
		"border-input bg-background ring-offset-background placeholder:text-muted-foreground focus-visible:ring-ring flex h-10 w-full rounded-md border px-3 py-2 text-sm file:border-0 file:bg-transparent file:text-sm file:font-medium focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
		className
	)}
	bind:value
	{readonly}
	on:blur
	on:change
	on:click
	on:focus
	on:focusin
	on:focusout
	on:keydown
	on:keypress
	on:keyup
	on:mouseover
	on:mouseenter
	on:mouseleave
	on:mousemove
	on:paste
	on:input
	on:wheel|passive
	{...$$restProps}
/>

================
File: src/lib/components/ui/resizable/index.ts
================
import { Pane } from "paneforge";
import Handle from "./resizable-handle.svelte";
import PaneGroup from "./resizable-pane-group.svelte";

export {
	PaneGroup,
	Pane,
	Handle,
	//
	PaneGroup as ResizablePaneGroup,
	Pane as ResizablePane,
	Handle as ResizableHandle,
};

================
File: src/lib/components/ui/resizable/resizable-handle.svelte
================
<script lang="ts">
	import GripVertical from "lucide-svelte/icons/grip-vertical";
	import * as ResizablePrimitive from "paneforge";
	import { cn } from "$lib/utils.js";

	type $$Props = ResizablePrimitive.PaneResizerProps & {
		withHandle?: boolean;
	};

	export let withHandle: $$Props["withHandle"] = false;
	export let el: $$Props["el"] = undefined;
	let className: $$Props["class"] = undefined;
	export { className as class };
</script>

<ResizablePrimitive.PaneResizer
	bind:el
	class={cn(
		"bg-border focus-visible:ring-ring relative flex w-px items-center justify-center after:absolute after:inset-y-0 after:left-1/2 after:w-1 after:-translate-x-1/2 focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-offset-1 data-[direction=vertical]:h-px data-[direction=vertical]:w-full data-[direction=vertical]:after:left-0 data-[direction=vertical]:after:h-1 data-[direction=vertical]:after:w-full data-[direction=vertical]:after:-translate-y-1/2 data-[direction=vertical]:after:translate-x-0 [&[data-direction=vertical]>div]:rotate-90",
		className
	)}
>
	{#if withHandle}
		<div class="bg-border z-10 flex h-4 w-3 items-center justify-center rounded-sm border">
			<GripVertical class="h-2.5 w-2.5" />
		</div>
	{/if}
</ResizablePrimitive.PaneResizer>

================
File: src/lib/components/ui/resizable/resizable-pane-group.svelte
================
<script lang="ts">
	import * as ResizablePrimitive from "paneforge";
	import { cn } from "$lib/utils.js";

	type $$Props = ResizablePrimitive.PaneGroupProps;

	let className: $$Props["class"] = undefined;
	export let direction: $$Props["direction"];
	export let paneGroup: $$Props["paneGroup"] = undefined;
	export let el: $$Props["el"] = undefined;
	export { className as class };
</script>

<ResizablePrimitive.PaneGroup
	bind:el
	bind:paneGroup
	{direction}
	class={cn("flex h-full w-full data-[direction=vertical]:flex-col", className)}
	{...$$restProps}
>
	<slot />
</ResizablePrimitive.PaneGroup>

================
File: src/lib/components/ui/sheet/index.ts
================
import { Dialog as SheetPrimitive } from "bits-ui";
import { type VariantProps, tv } from "tailwind-variants";

import Portal from "./sheet-portal.svelte";
import Overlay from "./sheet-overlay.svelte";
import Content from "./sheet-content.svelte";
import Header from "./sheet-header.svelte";
import Footer from "./sheet-footer.svelte";
import Title from "./sheet-title.svelte";
import Description from "./sheet-description.svelte";

const Root = SheetPrimitive.Root;
const Close = SheetPrimitive.Close;
const Trigger = SheetPrimitive.Trigger;

export {
	Root,
	Close,
	Trigger,
	Portal,
	Overlay,
	Content,
	Header,
	Footer,
	Title,
	Description,
	//
	Root as Sheet,
	Close as SheetClose,
	Trigger as SheetTrigger,
	Portal as SheetPortal,
	Overlay as SheetOverlay,
	Content as SheetContent,
	Header as SheetHeader,
	Footer as SheetFooter,
	Title as SheetTitle,
	Description as SheetDescription,
};

export const sheetVariants = tv({
	base: "bg-background fixed z-50 gap-4 p-6 shadow-lg",
	variants: {
		side: {
			top: "inset-x-0 top-0 border-b",
			bottom: "inset-x-0 bottom-0 border-t",
			left: "inset-y-0 left-0 h-full w-3/4 border-r sm:max-w-sm",
			right: "inset-y-0 right-0 h-full w-3/4  border-l sm:max-w-sm",
		},
	},
	defaultVariants: {
		side: "right",
	},
});

export const sheetTransitions = {
	top: {
		in: {
			y: "-100%",
			duration: 500,
			opacity: 1,
		},
		out: {
			y: "-100%",
			duration: 300,
			opacity: 1,
		},
	},
	bottom: {
		in: {
			y: "100%",
			duration: 500,
			opacity: 1,
		},
		out: {
			y: "100%",
			duration: 300,
			opacity: 1,
		},
	},
	left: {
		in: {
			x: "-100%",
			duration: 500,
			opacity: 1,
		},
		out: {
			x: "-100%",
			duration: 300,
			opacity: 1,
		},
	},
	right: {
		in: {
			x: "100%",
			duration: 500,
			opacity: 1,
		},
		out: {
			x: "100%",
			duration: 300,
			opacity: 1,
		},
	},
};

export type Side = VariantProps<typeof sheetVariants>["side"];

================
File: src/lib/components/ui/sheet/sheet-content.svelte
================
<script lang="ts">
	import { Dialog as SheetPrimitive } from "bits-ui";
	import X from "lucide-svelte/icons/x";
	import { fly } from "svelte/transition";
	import {
		SheetOverlay,
		SheetPortal,
		type Side,
		sheetTransitions,
		sheetVariants,
	} from "./index.js";
	import { cn } from "$lib/utils.js";

	type $$Props = SheetPrimitive.ContentProps & {
		side?: Side;
	};

	let className: $$Props["class"] = undefined;
	export let side: $$Props["side"] = "right";
	export { className as class };
	export let inTransition: $$Props["inTransition"] = fly;
	export let inTransitionConfig: $$Props["inTransitionConfig"] =
		sheetTransitions[side ?? "right"].in;
	export let outTransition: $$Props["outTransition"] = fly;
	export let outTransitionConfig: $$Props["outTransitionConfig"] =
		sheetTransitions[side ?? "right"].out;
</script>

<SheetPortal>
	<SheetOverlay />
	<SheetPrimitive.Content
		{inTransition}
		{inTransitionConfig}
		{outTransition}
		{outTransitionConfig}
		class={cn(sheetVariants({ side }), className)}
		{...$$restProps}
	>
		<slot />
		<SheetPrimitive.Close
			class="ring-offset-background focus:ring-ring data-[state=open]:bg-secondary absolute right-4 top-4 rounded-sm opacity-70 transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-offset-2 disabled:pointer-events-none"
		>
			<X class="h-4 w-4" />
			<span class="sr-only">Close</span>
		</SheetPrimitive.Close>
	</SheetPrimitive.Content>
</SheetPortal>

================
File: src/lib/components/ui/sheet/sheet-description.svelte
================
<script lang="ts">
	import { Dialog as SheetPrimitive } from "bits-ui";
	import { cn } from "$lib/utils.js";

	type $$Props = SheetPrimitive.DescriptionProps;

	let className: $$Props["class"] = undefined;
	export { className as class };
</script>

<SheetPrimitive.Description class={cn("text-muted-foreground text-sm", className)} {...$$restProps}>
	<slot />
</SheetPrimitive.Description>

================
File: src/lib/components/ui/sheet/sheet-footer.svelte
================
<script lang="ts">
	import type { HTMLAttributes } from "svelte/elements";
	import { cn } from "$lib/utils.js";

	type $$Props = HTMLAttributes<HTMLDivElement>;

	let className: $$Props["class"] = undefined;
	export { className as class };
</script>

<div
	class={cn("flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2", className)}
	{...$$restProps}
>
	<slot />
</div>

================
File: src/lib/components/ui/sheet/sheet-header.svelte
================
<script lang="ts">
	import type { HTMLAttributes } from "svelte/elements";
	import { cn } from "$lib/utils.js";

	type $$Props = HTMLAttributes<HTMLDivElement>;

	let className: $$Props["class"] = undefined;
	export { className as class };
</script>

<div class={cn("flex flex-col space-y-2 text-center sm:text-left", className)} {...$$restProps}>
	<slot />
</div>

================
File: src/lib/components/ui/sheet/sheet-overlay.svelte
================
<script lang="ts">
	import { Dialog as SheetPrimitive } from "bits-ui";
	import { fade } from "svelte/transition";
	import { cn } from "$lib/utils.js";

	type $$Props = SheetPrimitive.OverlayProps;

	let className: $$Props["class"] = undefined;
	export let transition: $$Props["transition"] = fade;
	export let transitionConfig: $$Props["transitionConfig"] = {
		duration: 150,
	};
	export { className as class };
</script>

<SheetPrimitive.Overlay
	{transition}
	{transitionConfig}
	class={cn("bg-background/80 fixed inset-0 z-50 backdrop-blur-sm ", className)}
	{...$$restProps}
/>

================
File: src/lib/components/ui/sheet/sheet-portal.svelte
================
<script lang="ts">
	import { Dialog as SheetPrimitive } from "bits-ui";
	import { cn } from "$lib/utils.js";

	type $$Props = SheetPrimitive.PortalProps;

	let className: $$Props["class"] = undefined;
	export { className as class };
</script>

<SheetPrimitive.Portal class={cn(className)} {...$$restProps}>
	<slot />
</SheetPrimitive.Portal>

================
File: src/lib/components/ui/sheet/sheet-title.svelte
================
<script lang="ts">
	import { Dialog as SheetPrimitive } from "bits-ui";
	import { cn } from "$lib/utils.js";

	type $$Props = SheetPrimitive.TitleProps;

	let className: $$Props["class"] = undefined;
	export { className as class };
</script>

<SheetPrimitive.Title
	class={cn("text-foreground text-lg font-semibold", className)}
	{...$$restProps}
>
	<slot />
</SheetPrimitive.Title>

================
File: src/lib/components/ui/tabs/index.ts
================
import { Tabs as TabsPrimitive } from "bits-ui";
import Content from "./tabs-content.svelte";
import List from "./tabs-list.svelte";
import Trigger from "./tabs-trigger.svelte";

const Root = TabsPrimitive.Root;

export {
	Root,
	Content,
	List,
	Trigger,
	//
	Root as Tabs,
	Content as TabsContent,
	List as TabsList,
	Trigger as TabsTrigger,
};

================
File: src/lib/components/ui/tabs/tabs-content.svelte
================
<script lang="ts">
	import { Tabs as TabsPrimitive } from "bits-ui";
	import { cn } from "$lib/utils.js";

	type $$Props = TabsPrimitive.ContentProps;

	let className: $$Props["class"] = undefined;
	export let value: $$Props["value"];
	export { className as class };
</script>

<TabsPrimitive.Content
	class={cn(
		"ring-offset-background focus-visible:ring-ring mt-2 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2",
		className
	)}
	{value}
	{...$$restProps}
>
	<slot />
</TabsPrimitive.Content>

================
File: src/lib/components/ui/tabs/tabs-list.svelte
================
<script lang="ts">
	import { Tabs as TabsPrimitive } from "bits-ui";
	import { cn } from "$lib/utils.js";

	type $$Props = TabsPrimitive.ListProps;

	let className: $$Props["class"] = undefined;
	export { className as class };
</script>

<TabsPrimitive.List
	class={cn(
		"bg-muted text-muted-foreground inline-flex h-10 items-center justify-center rounded-md p-1",
		className
	)}
	{...$$restProps}
>
	<slot />
</TabsPrimitive.List>

================
File: src/lib/components/ui/tabs/tabs-trigger.svelte
================
<script lang="ts">
	import { Tabs as TabsPrimitive } from "bits-ui";
	import { cn } from "$lib/utils.js";

	type $$Props = TabsPrimitive.TriggerProps;
	type $$Events = TabsPrimitive.TriggerEvents;

	let className: $$Props["class"] = undefined;
	export let value: $$Props["value"];
	export { className as class };
</script>

<TabsPrimitive.Trigger
	class={cn(
		"ring-offset-background focus-visible:ring-ring data-[state=active]:bg-background data-[state=active]:text-foreground inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:shadow-sm",
		className
	)}
	{value}
	{...$$restProps}
	on:click
>
	<slot />
</TabsPrimitive.Trigger>

================
File: src/lib/components/ui/textarea/index.ts
================
import Root from "./textarea.svelte";

type FormTextareaEvent<T extends Event = Event> = T & {
	currentTarget: EventTarget & HTMLTextAreaElement;
};

type TextareaEvents = {
	blur: FormTextareaEvent<FocusEvent>;
	change: FormTextareaEvent<Event>;
	click: FormTextareaEvent<MouseEvent>;
	focus: FormTextareaEvent<FocusEvent>;
	keydown: FormTextareaEvent<KeyboardEvent>;
	keypress: FormTextareaEvent<KeyboardEvent>;
	keyup: FormTextareaEvent<KeyboardEvent>;
	mouseover: FormTextareaEvent<MouseEvent>;
	mouseenter: FormTextareaEvent<MouseEvent>;
	mouseleave: FormTextareaEvent<MouseEvent>;
	paste: FormTextareaEvent<ClipboardEvent>;
	input: FormTextareaEvent<InputEvent>;
};

export {
	Root,
	//
	Root as Textarea,
	type TextareaEvents,
	type FormTextareaEvent,
};

================
File: src/lib/components/ui/textarea/textarea.svelte
================
<script lang="ts">
	import type { HTMLTextareaAttributes } from "svelte/elements";
	import type { TextareaEvents } from "./index.js";
	import { cn } from "$lib/utils.js";

	type $$Props = HTMLTextareaAttributes;
	type $$Events = TextareaEvents;

	let className: $$Props["class"] = undefined;
	export let value: $$Props["value"] = undefined;
	export { className as class };

	// Workaround for https://github.com/sveltejs/svelte/issues/9305
	// Fixed in Svelte 5, but not backported to 4.x.
	export let readonly: $$Props["readonly"] = undefined;
</script>

<textarea
	class={cn(
		"border-input bg-background ring-offset-background placeholder:text-muted-foreground focus-visible:ring-ring flex min-h-[80px] w-full rounded-md border px-3 py-2 text-sm focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
		className
	)}
	bind:value
	{readonly}
	on:blur
	on:change
	on:click
	on:focus
	on:keydown
	on:keypress
	on:keyup
	on:mouseover
	on:mouseenter
	on:mouseleave
	on:paste
	on:input
	{...$$restProps}
></textarea>

================
File: src/lib/services/api.ts
================
// lib/services/api.ts

import type { ApiBlockConfig } from "$lib/types/apiBlockConfig";

class ApiError extends Error {
    constructor(
        message: string,
        public status?: number,
        public response?: any,
        public config?: ApiBlockConfig
    ) {
        super(message);
        this.name = 'ApiError';
    }
}

async function delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
}

async function parseResponse(response: Response, responseType: string = 'json') {
    try {
        switch (responseType) {
            case 'json':
                return await response.json();
            case 'text':
                return await response.text();
            case 'blob':
                return await response.blob();
            case 'arraybuffer':
                return await response.arrayBuffer();
            default:
                return await response.json();
        }
    } catch (error) {
        throw new ApiError(
            `Failed to parse response as ${responseType}`,
            response.status,
            error
        );
    }
}

export async function executeApiCall(config: ApiBlockConfig) {
    const retryConfig = config.retryConfig || { maxRetries: 3, retryDelay: 1000 };
    let attempt = 0;

    while (attempt <= retryConfig.maxRetries) {
        try {
            console.log(`🚀 Starting API call attempt ${attempt + 1}/${retryConfig.maxRetries + 1}`, config);
            
            const url = new URL(config.url);
            
            // Add query parameters
            if (config.queryParams) {
                Object.entries(config.queryParams).forEach(([key, value]) => {
                    url.searchParams.append(key, String(value));
                });
            }

            // Prepare headers with authentication
            const headers: Record<string, string> = {
                'Content-Type': 'application/json',
                ...config.headers
            };

            if (config.authentication) {
                switch (config.authentication.type) {
                    case 'basic':
                        const credentials = btoa(`${config.authentication.username}:${config.authentication.password}`);
                        headers['Authorization'] = `Basic ${credentials}`;
                        break;
                    case 'bearer':
                        headers['Authorization'] = `Bearer ${config.authentication.token}`;
                        break;
                    case 'api-key':
                        if (config.authentication.apiKeyIn === 'header') {
                            headers[config.authentication.apiKeyName || 'X-API-Key'] = config.authentication.apiKey || '';
                        } else if (config.authentication.apiKeyIn === 'query') {
                            url.searchParams.append(
                                config.authentication.apiKeyName || 'apiKey',
                                config.authentication.apiKey || ''
                            );
                        }
                        break;
                }
            }

            const requestConfig = {
                method: config.method,
                headers,
                body: config.method !== 'GET' && config.body 
                    ? config.body
                    : undefined,
                signal: config.timeout 
                    ? AbortSignal.timeout(config.timeout)
                    : undefined
            };

            console.log('📡 Making fetch request to:', url.toString());
            console.log('⚙️ Request configuration:', {
                method: requestConfig.method,
                headers: requestConfig.headers,
                body: config.body
            });

            const response = await fetch(url.toString(), requestConfig);
            
            // Validate response status
            const validateStatus = config.validateStatus || ((status: number) => status >= 200 && status < 300);
            if (!validateStatus(response.status)) {
                throw new ApiError(
                    `Request failed with status ${response.status}`,
                    response.status,
                    await parseResponse(response, config.responseType),
                    config
                );
            }

            // Parse response based on type
            const result = await parseResponse(response, config.responseType);
            console.log('✅ Request successful:', { status: response.status, data: result });
            return result;

        } catch (error) {
            console.error(`❌ Attempt ${attempt + 1} failed:`, error);
            
            // Don't retry if it's a timeout or validation error
            if (
                error instanceof ApiError ||
                error instanceof TypeError ||
                attempt >= retryConfig.maxRetries
            ) {
                throw error;
            }

            // Wait before retrying
            await delay(retryConfig.retryDelay);
            attempt++;
        }
    }
}

================
File: src/lib/stores/api.ts
================
import { writable } from 'svelte/store';
import { browser } from '$app/environment';

export interface ApiConfig {
    id: string;
    name: string;
    endpoint: string;
    method: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH';
    headers?: Record<string, string>;
    body?: string;
    queryParams?: Record<string, string>;
    timeout?: number;
    retryConfig?: {
        maxRetries: number;
        retryDelay: number;
    };
    authentication?: {
        type: 'none' | 'basic' | 'bearer' | 'api-key';
        username?: string;
        password?: string;
        token?: string;
        apiKey?: string;
        apiKeyName?: string;
        apiKeyIn?: 'header' | 'query';
    };
    responseType?: 'json' | 'text' | 'blob' | 'arraybuffer';
    validateStatus?: (status: number) => boolean;
    createdAt: number;
    updatedAt: number;
}

const STORAGE_KEY = 'blockbuilder_apis';

function createApiStore() {
    // Initialize the store with data from localStorage or empty array
    const initialValue = browser 
        ? JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]') 
        : [];
    
    const { subscribe, set, update } = writable<ApiConfig[]>(initialValue);

    return {
        subscribe,
        
        /**
         * Adds a new API configuration to the store
         * @param api - The API configuration to add (without id, createdAt, and updatedAt)
         * @remarks
         * Default values are automatically set for:
         * - timeout: 30000ms
         * - retryConfig: { maxRetries: 3, retryDelay: 1000 }
         * - authentication: { type: 'none' }
         * - responseType: 'json'
         * - validateStatus: accepts 200-299 status codes
         * 
         * The method automatically:
         * - Generates a unique UUID for the API
         * - Sets createdAt timestamp
         * - Persists to localStorage in browser environment
         */
        add: (api: Omit<ApiConfig, 'id' | 'createdAt' | 'updatedAt'>) => {
            update(apis => {
                const newApi: ApiConfig = {
                    ...api,
                    id: crypto.randomUUID(),
                    timeout: api.timeout || 30000,
                    retryConfig: api.retryConfig || { maxRetries: 3, retryDelay: 1000 },
                    authentication: api.authentication || { type: 'none' },
                    responseType: api.responseType || 'json',
                    validateStatus: api.validateStatus || ((status: number) => status >= 200 && status < 300),
                    createdAt: Date.now(),
                    updatedAt: Date.now(),
                };
                const updatedApis = [...apis, newApi];
                if (browser) {
                    localStorage.setItem(STORAGE_KEY, JSON.stringify(updatedApis));
                }
                return updatedApis;
            });
        },

        /**
         * Updates an existing API configuration in the store
         * @param id - The unique identifier of the API to update
         * @param updates - Partial API configuration containing the fields to update
         *                 (excluding id, createdAt, and updatedAt which are managed internally)
         * @remarks
         * - The method automatically updates the 'updatedAt' timestamp
         * - Changes are persisted to localStorage if running in browser environment
         * - If the API with the given id doesn't exist, no changes are made
         */
        update: (id: string, updates: Partial<Omit<ApiConfig, 'id' | 'createdAt' | 'updatedAt'>>) => {
            update(apis => {
                const updatedApis = apis.map(api => 
                    api.id === id 
                        ? { ...api, ...updates, updatedAt: Date.now() }
                        : api
                );
                if (browser) {
                    localStorage.setItem(STORAGE_KEY, JSON.stringify(updatedApis));
                }
                return updatedApis;
            });
        },

        // Remove an API
        remove: (id: string) => {
            update(apis => {
                const updatedApis = apis.filter(api => api.id !== id);
                if (browser) {
                    localStorage.setItem(STORAGE_KEY, JSON.stringify(updatedApis));
                }
                return updatedApis;
            });
        },

        // Clear all APIs
        clear: () => {
            set([]);
            if (browser) {
                localStorage.removeItem(STORAGE_KEY);
            }
        },

        // Generate cURL command for an API configuration
        generateCurl: (api: ApiConfig): string => {
            let command = ['curl'];
            
            // Method
            if (api.method !== 'GET') {
                command.push(`-X ${api.method}`);
            }
            
            // Headers with Content-Type
            const headers = { ...api.headers };
            if (api.method !== 'GET' && !headers['Content-Type']) {
                headers['Content-Type'] = 'application/json';
            }
            
            Object.entries(headers).forEach(([key, value]) => {
                if (key && value) {
                    command.push(`-H "${key}: ${value}"`);
                }
            });
            
            // Authentication
            if (api.authentication) {
                switch (api.authentication.type) {
                    case 'basic':
                        if (api.authentication.username && api.authentication.password) {
                            command.push(`-u "${api.authentication.username}:${api.authentication.password}"`);
                        }
                        break;
                    case 'bearer':
                        if (api.authentication.token) {
                            command.push(`-H "Authorization: Bearer ${api.authentication.token}"`);
                        }
                        break;
                    case 'api-key':
                        if (api.authentication.apiKeyIn === 'header' && api.authentication.apiKeyName && api.authentication.apiKey) {
                            command.push(`-H "${api.authentication.apiKeyName}: ${api.authentication.apiKey}"`);
                        }
                        break;
                }
            }
            
            // Body (with proper JSON formatting)
            if (api.body && api.method !== 'GET') {
                try {
                    // Try to parse and format JSON
                    const jsonBody = JSON.parse(api.body);
                    command.push(`-d '${JSON.stringify(jsonBody)}'`);
                } catch {
                    // If not valid JSON, use as is
                    command.push(`-d '${api.body}'`);
                }
            }
            
            // URL with query parameters
            let url = api.endpoint;
            if (api.queryParams && Object.keys(api.queryParams).length > 0) {
                const params = new URLSearchParams();
                Object.entries(api.queryParams).forEach(([key, value]) => {
                    if (key && value !== undefined && value !== null) {
                        params.append(key, String(value));
                    }
                });
                const queryString = params.toString();
                if (queryString) {
                    url += (url.includes('?') ? '&' : '?') + queryString;
                }
            }
            command.push(`"${url}"`);
            
            return command.join(' ');
        }
    };
}

export const apiStore = createApiStore();

================
File: src/lib/stores/canvas.ts
================
// lib/stores/canvas.ts
import { writable } from 'svelte/store';
import type { Block } from '$lib/types/canvas';

export interface CanvasState {
  isDragging: boolean;
  lastX: number;
  lastY: number;
  offsetX: number;
  offsetY: number;
  scale: number;
  mouseX: number;
  mouseY: number;
  blocks: Block[];
  selectedBlockId: string | null;
  draggingBlock: boolean;
}

export const canvasStore = writable<CanvasState>({
  isDragging: false,
  lastX: 0,
  lastY: 0,
  offsetX: 0,
  offsetY: 0,
  scale: 1,
  mouseX: 0,
  mouseY: 0,
  blocks: [],
  selectedBlockId: null,
  draggingBlock: false
});

================
File: src/lib/types/apiBlockConfig.ts
================
export interface ApiBlockConfig {
    name?: string;
    method: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH';
    url: string;
    headers: Record<string, string>;
    body?: string;
    queryParams?: Record<string, any>;
    responseMapping?: Record<string, string>;
    timeout?: number;
    retryConfig?: {
      maxRetries: number;
      retryDelay: number;
    };
    authentication?: {
      type: 'none' | 'basic' | 'bearer' | 'api-key';
      username?: string;
      password?: string;
      token?: string;
      apiKey?: string;
      apiKeyName?: string;
      apiKeyIn?: 'header' | 'query';
    };
    responseType?: 'json' | 'text' | 'blob' | 'arraybuffer';
    requestBody?: any;
    validateStatus?: (status: number) => boolean;
  }

================
File: src/lib/types/block.ts
================
import type { ApiBlockConfig } from "./apiBlockConfig";

export interface Block {
    id: string;
    x: number;
    y: number;
    width: number;
    height: number;
    type: 'api';
    config: ApiBlockConfig;
  }

================
File: src/lib/types/canvas.ts
================
import type { Block } from "./block";

export interface Point {
    x: number;
    y: number;
  }

export interface CanvasState {
  isDragging: boolean;
  lastX: number;
  lastY: number;
  offsetX: number;
  offsetY: number;
  scale: number;
  mouseX: number;
  mouseY: number;
  blocks: Block[];
  draggingBlock: boolean;
  selectedBlockId: string | null;
}

  export interface CanvasProps {
    width?: number;
    height?: number;
  }
  
  export interface ControlPanelProps {
    mouseX: number;
    mouseY: number;
    scale: number;
    offsetX: number;
    offsetY: number;
  }

================
File: src/lib/utils/canvas/blocks.ts
================
// lib/utils/canvas/blocks.ts
import type { Block, Point, ApiBlockConfig } from '$lib/types/canvas';

export function createBlock(position: Point): Block {
  // Create a default API block configuration
  const defaultConfig: ApiBlockConfig = {
    method: 'GET',
    url: 'https://api.example.com',
    headers: {
      'Content-Type': 'application/json'
    },
    bodyParams: {},
    queryParams: {},
    responseMapping: {}
  };

  return {
    id: crypto.randomUUID(),
    x: position.x,
    y: position.y,
    width: 300, // Increased width to accommodate API UI
    height: 200, // Increased height to accommodate API UI
    type: 'api', // Specify that this is an API block
    config: defaultConfig
  };
}

export function updateBlockPosition(block: Block, position: Point): Block {
  return {
    ...block,
    x: position.x,
    y: position.y
  };
}

export function isPointInBlock(point: Point, block: Block): boolean {
  return (
    point.x >= block.x &&
    point.x <= block.x + block.width &&
    point.y >= block.y &&
    point.y <= block.height
  );
}

// Add new utility functions for API blocks

export function validateBlockConfig(block: Block): string[] {
  const errors: string[] = [];

  if (!block.config.url) {
    errors.push('URL is required');
  } else {
    try {
      new URL(block.config.url);
    } catch {
      errors.push('Invalid URL format');
    }
  }

  if (!['GET', 'POST', 'PUT', 'DELETE', 'PATCH'].includes(block.config.method)) {
    errors.push('Invalid HTTP method');
  }

  return errors;
}

export function cloneBlock(block: Block): Block {
  return {
    ...block,
    id: crypto.randomUUID(),
    x: block.x + 20, // Offset the clone slightly
    y: block.y + 20,
    config: {
      ...block.config,
      headers: { ...block.config.headers },
      bodyParams: { ...block.config.bodyParams },
      queryParams: { ...block.config.queryParams },
      responseMapping: { ...block.config.responseMapping }
    }
  };
}

export function resizeBlock(block: Block, width: number, height: number): Block {
  return {
    ...block,
    width: Math.max(200, width), // Minimum width
    height: Math.max(150, height) // Minimum height
  };
}

export function updateBlockConfig(block: Block, config: Partial<ApiBlockConfig>): Block {
  return {
    ...block,
    config: {
      ...block.config,
      ...config,
      // Preserve nested objects if not provided in the update
      headers: config.headers ?? block.config.headers,
      bodyParams: config.bodyParams ?? block.config.bodyParams,
      queryParams: config.queryParams ?? block.config.queryParams,
      responseMapping: config.responseMapping ?? block.config.responseMapping
    }
  };
}

// Helper function to get block connections (if implementing block chaining)
export function getConnectedBlocks(block: Block, allBlocks: Block[]): Block[] {
  // This is a placeholder for implementing block connection logic
  // You could add properties to the Block type to track connections
  return allBlocks.filter(b => b.id !== block.id);
}

// Helper function to validate block placement
export function isValidBlockPlacement(
  block: Block,
  allBlocks: Block[],
  canvasWidth: number,
  canvasHeight: number
): boolean {
  // Check if block is within canvas bounds
  if (
    block.x < 0 ||
    block.y < 0 ||
    block.x + block.width > canvasWidth ||
    block.y + block.height > canvasHeight
  ) {
    return false;
  }

  // Check for collisions with other blocks
  // You might want to allow some overlap depending on your requirements
  return !allBlocks.some(
    other =>
      other.id !== block.id &&
      block.x < other.x + other.width &&
      block.x + block.width > other.x &&
      block.y < other.y + other.height &&
      block.y + block.height > other.y
  );
}

================
File: src/lib/utils/canvas/draw.ts
================
import type { Block } from "$lib/types/canvas";

export function drawGrid(
    ctx: CanvasRenderingContext2D, 
    canvas: HTMLCanvasElement,
    scale: number,
    offsetX: number,
    offsetY: number
  ) {
    const gridSize = 50;
    const width = canvas.width / scale;
    const height = canvas.height / scale;
    
    const startX = Math.floor(-offsetX / scale / gridSize) * gridSize;
    const startY = Math.floor(-offsetY / scale / gridSize) * gridSize;
    const endX = startX + width + gridSize;
    const endY = startY + height + gridSize;
    
    ctx.beginPath();
    ctx.strokeStyle = '#ddd';
    ctx.lineWidth = 1 / scale;
    
    // Draw vertical lines
    for (let x = startX; x < endX; x += gridSize) {
      ctx.moveTo(x, startY);
      ctx.lineTo(x, endY);
    }
    
    // Draw horizontal lines
    for (let y = startY; y < endY; y += gridSize) {
      ctx.moveTo(startX, y);
      ctx.lineTo(endX, y);
    }
    
    ctx.stroke();
  }

  export function drawBlock(
    ctx: CanvasRenderingContext2D,
    block: Block
  ) {
    ctx.fillStyle = '#4299e1'; // blue-500
    ctx.fillRect(block.x, block.y, block.width, block.height);
  }

================
File: src/lib/utils/canvas/events.ts
================
import type { CanvasState } from '$lib/types/canvas';

export function handleMouseMove(
  event: MouseEvent,
  state: CanvasState
): Partial<CanvasState> {
  if (!state.isDragging) {
    return {
      mouseX: (event.clientX - state.offsetX) / state.scale,
      mouseY: (event.clientY - state.offsetY) / state.scale
    };
  }

  const deltaX = event.clientX - state.lastX;
  const deltaY = event.clientY - state.lastY;

  return {
    offsetX: state.offsetX + deltaX,
    offsetY: state.offsetY + deltaY,
    lastX: event.clientX,
    lastY: event.clientY,
    mouseX: (event.clientX - state.offsetX) / state.scale,
    mouseY: (event.clientY - state.offsetY) / state.scale
  };
}

export function handleWheel(
  event: WheelEvent,
  state: CanvasState
): Partial<CanvasState> {
  const zoomFactor = 0.95;
  const mouseX = event.clientX;
  const mouseY = event.clientY;
  
  const pointXBeforeZoom = (mouseX - state.offsetX) / state.scale;
  const pointYBeforeZoom = (mouseY - state.offsetY) / state.scale;
  
  const newScale = event.deltaY > 0 
    ? state.scale * zoomFactor 
    : state.scale / zoomFactor;
  
  const scale = Math.min(Math.max(0.1, newScale), 5);
  
  const pointXAfterZoom = (mouseX - state.offsetX) / scale;
  const pointYAfterZoom = (mouseY - state.offsetY) / scale;
  
  return {
    scale,
    offsetX: state.offsetX + (pointXAfterZoom - pointXBeforeZoom) * scale,
    offsetY: state.offsetY + (pointYAfterZoom - pointYBeforeZoom) * scale
  };
}

================
File: src/lib/utils/canvas/setup.ts
================
export function setupCanvas(canvas: HTMLCanvasElement) {
    const ctx = canvas.getContext('2d');
    if (!ctx) throw new Error('Could not get canvas context');
    
    return ctx;
  }
  
  export function resizeCanvas(canvas: HTMLCanvasElement) {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }

================
File: src/lib/i18n.ts
================
import * as runtime from '$lib/paraglide/runtime';
import { createI18n } from '@inlang/paraglide-sveltekit';
export const i18n = createI18n(runtime);

================
File: src/lib/index.ts
================
// place files you want to import through the `$lib` alias in this folder.

================
File: src/lib/utils.ts
================
import { type ClassValue, clsx } from "clsx";
import { twMerge } from "tailwind-merge";
import { cubicOut } from "svelte/easing";
import type { TransitionConfig } from "svelte/transition";

export function cn(...inputs: ClassValue[]) {
	return twMerge(clsx(inputs));
}

type FlyAndScaleParams = {
	y?: number;
	x?: number;
	start?: number;
	duration?: number;
};

export const flyAndScale = (
	node: Element,
	params: FlyAndScaleParams = { y: -8, x: 0, start: 0.95, duration: 150 }
): TransitionConfig => {
	const style = getComputedStyle(node);
	const transform = style.transform === "none" ? "" : style.transform;

	const scaleConversion = (
		valueA: number,
		scaleA: [number, number],
		scaleB: [number, number]
	) => {
		const [minA, maxA] = scaleA;
		const [minB, maxB] = scaleB;

		const percentage = (valueA - minA) / (maxA - minA);
		const valueB = percentage * (maxB - minB) + minB;

		return valueB;
	};

	const styleToString = (
		style: Record<string, number | string | undefined>
	): string => {
		return Object.keys(style).reduce((str, key) => {
			if (style[key] === undefined) return str;
			return str + `${key}:${style[key]};`;
		}, "");
	};

	return {
		duration: params.duration ?? 200,
		delay: 0,
		css: (t) => {
			const y = scaleConversion(t, [0, 1], [params.y ?? 5, 0]);
			const x = scaleConversion(t, [0, 1], [params.x ?? 0, 0]);
			const scale = scaleConversion(t, [0, 1], [params.start ?? 0.95, 1]);

			return styleToString({
				transform: `${transform} translate3d(${x}px, ${y}px, 0) scale(${scale})`,
				opacity: t
			});
		},
		easing: cubicOut
	};
};

================
File: src/routes/+layout.svelte
================
<script lang="ts">
	import { i18n } from '$lib/i18n';
	import { ParaglideJS } from '@inlang/paraglide-sveltekit';
	import '../app.css';
	let { children } = $props();
</script>

<ParaglideJS {i18n}>
	{@render children()}
</ParaglideJS>

================
File: src/routes/+page.svelte
================
<script lang="ts">
	import Canvas from '$lib/components/features/canvas/Canvas.svelte';
	import ControlPanel from '$lib/components/features/canvas/ControlPanel.svelte';
    import { canvasStore } from '$lib/stores/canvas';
  </script>
  
  <Canvas />
  <ControlPanel {...$canvasStore} />

================
File: src/app.css
================
@tailwind base;
@tailwind components;
@tailwind utilities;
 
@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 222.2 84% 4.9%;
 
    --muted: 210 40% 96.1%;
    --muted-foreground: 215.4 16.3% 46.9%;
 
    --popover: 0 0% 100%;
    --popover-foreground: 222.2 84% 4.9%;
 
    --card: 0 0% 100%;
    --card-foreground: 222.2 84% 4.9%;
 
    --border: 214.3 31.8% 91.4%;
    --input: 214.3 31.8% 91.4%;
 
    --primary: 222.2 47.4% 11.2%;
    --primary-foreground: 210 40% 98%;
 
    --secondary: 210 40% 96.1%;
    --secondary-foreground: 222.2 47.4% 11.2%;
 
    --accent: 210 40% 96.1%;
    --accent-foreground: 222.2 47.4% 11.2%;
 
    --destructive: 0 72.2% 50.6%;
    --destructive-foreground: 210 40% 98%;
 
    --ring: 222.2 84% 4.9%;
 
    --radius: 0.5rem;
  }
 
  .dark {
    --background: 222.2 84% 4.9%;
    --foreground: 210 40% 98%;
 
    --muted: 217.2 32.6% 17.5%;
    --muted-foreground: 215 20.2% 65.1%;
 
    --popover: 222.2 84% 4.9%;
    --popover-foreground: 210 40% 98%;
 
    --card: 222.2 84% 4.9%;
    --card-foreground: 210 40% 98%;
 
    --border: 217.2 32.6% 17.5%;
    --input: 217.2 32.6% 17.5%;
 
    --primary: 210 40% 98%;
    --primary-foreground: 222.2 47.4% 11.2%;
 
    --secondary: 217.2 32.6% 17.5%;
    --secondary-foreground: 210 40% 98%;
 
    --accent: 217.2 32.6% 17.5%;
    --accent-foreground: 210 40% 98%;
 
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 210 40% 98%;
 
    --ring: 212.7 26.8% 83.9%;
  }
}
 
@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}

================
File: src/app.d.ts
================
// See https://svelte.dev/docs/kit/types#app.d.ts
// for information about these interfaces
declare global {
	namespace App {
		// interface Error {}
		// interface Locals {}
		// interface PageData {}
		// interface PageState {}
		// interface Platform {}
	}
}

export {};

================
File: src/app.html
================
<!doctype html>
<html lang="%paraglide.lang%" dir="%paraglide.textDirection%">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" href="%sveltekit.assets%/favicon.png" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		%sveltekit.head%
	</head>
	<body data-sveltekit-preload-data="hover">
		<div style="display: contents">%sveltekit.body%</div>
	</body>
</html>

================
File: src/demo.spec.ts
================
import { describe, it, expect } from 'vitest';

describe('sum test', () => {
	it('adds 1 + 2 to equal 3', () => {
		expect(1 + 2).toBe(3);
	});
});

================
File: src/hooks.server.ts
================
import type { Handle } from '@sveltejs/kit';
import { i18n } from '$lib/i18n';
const handleParaglide: Handle = i18n.handle();
export const handle: Handle = handleParaglide;

================
File: src/hooks.ts
================
import { i18n } from '$lib/i18n';
export const reroute = i18n.reroute();

================
File: .gitignore
================
test-results
node_modules

# Output
.output
.vercel
/.svelte-kit
/build

# OS
.DS_Store
Thumbs.db

# Env
.env
.env.*
!.env.example
!.env.test

# Vite
vite.config.js.timestamp-*
vite.config.ts.timestamp-*

================
File: .npmrc
================
engine-strict=true

================
File: .prettierignore
================
# Package Managers
package-lock.json
pnpm-lock.yaml
yarn.lock

================
File: .prettierrc
================
{
	"useTabs": true,
	"singleQuote": true,
	"trailingComma": "none",
	"printWidth": 100,
	"plugins": ["prettier-plugin-svelte", "prettier-plugin-tailwindcss"],
	"overrides": [
		{
			"files": "*.svelte",
			"options": {
				"parser": "svelte"
			}
		}
	]
}

================
File: components.json
================
{
	"$schema": "https://shadcn-svelte.com/schema.json",
	"style": "default",
	"tailwind": {
		"config": "tailwind.config.ts",
		"css": "src/app.css",
		"baseColor": "slate"
	},
	"aliases": {
		"components": "$lib/components",
		"utils": "$lib/utils"
	},
	"typescript": true
}

================
File: eslint.config.js
================
import prettier from 'eslint-config-prettier';
import js from '@eslint/js';
import svelte from 'eslint-plugin-svelte';
import globals from 'globals';
import ts from 'typescript-eslint';

export default ts.config(
	js.configs.recommended,
	...ts.configs.recommended,
	...svelte.configs['flat/recommended'],
	prettier,
	...svelte.configs['flat/prettier'],
	{
		languageOptions: {
			globals: {
				...globals.browser,
				...globals.node
			}
		}
	},
	{
		files: ['**/*.svelte'],

		languageOptions: {
			parserOptions: {
				parser: ts.parser
			}
		}
	},
	{
		ignores: ['build/', '.svelte-kit/', 'dist/']
	}
);

================
File: package.json
================
{
	"name": "blockbuilder",
	"version": "0.0.1",
	"type": "module",
	"scripts": {
		"dev": "vite dev",
		"build": "vite build",
		"preview": "vite preview",
		"check": "svelte-kit sync && svelte-check --tsconfig ./tsconfig.json",
		"check:watch": "svelte-kit sync && svelte-check --tsconfig ./tsconfig.json --watch",
		"format": "prettier --write .",
		"lint": "prettier --check . && eslint .",
		"test:unit": "vitest",
		"test": "npm run test:unit -- --run && npm run test:e2e",
		"test:e2e": "playwright test",
		"storybook": "storybook dev -p 6006",
		"build-storybook": "storybook build"
	},
	"devDependencies": {
		"@chromatic-com/storybook": "^3.2.2",
		"@playwright/test": "^1.45.3",
		"@storybook/addon-essentials": "^8.4.5",
		"@storybook/addon-interactions": "^8.4.5",
		"@storybook/addon-svelte-csf": "^5.0.0-next.11",
		"@storybook/blocks": "^8.4.5",
		"@storybook/svelte": "^8.4.5",
		"@storybook/sveltekit": "^8.4.5",
		"@storybook/test": "^8.4.5",
		"@sveltejs/adapter-auto": "^3.0.0",
		"@sveltejs/kit": "^2.0.0",
		"@sveltejs/vite-plugin-svelte": "^4.0.0",
		"autoprefixer": "^10.4.20",
		"bits-ui": "^0.21.16",
		"clsx": "^2.1.1",
		"eslint": "^9.7.0",
		"eslint-config-prettier": "^9.1.0",
		"eslint-plugin-svelte": "^2.36.0",
		"globals": "^15.0.0",
		"lucide-svelte": "^0.462.0",
		"mdsvex": "^0.11.2",
		"paneforge": "^0.0.6",
		"prettier": "^3.3.2",
		"prettier-plugin-svelte": "^3.2.6",
		"prettier-plugin-tailwindcss": "^0.6.5",
		"storybook": "^8.4.5",
		"svelte": "^5.0.0",
		"svelte-check": "^4.0.0",
		"tailwind-merge": "^2.5.5",
		"tailwind-variants": "^0.3.0",
		"tailwindcss": "^3.4.9",
		"typescript": "^5.0.0",
		"typescript-eslint": "^8.0.0",
		"vite": "^5.0.3",
		"vitest": "^2.0.4"
	},
	"dependencies": {
		"@inlang/paraglide-sveltekit": "^0.11.1",
		"@tailwindcss/container-queries": "^0.1.1",
		"@tailwindcss/forms": "^0.5.9",
		"@tailwindcss/typography": "^0.5.15"
	}
}

================
File: playwright.config.ts
================
import { defineConfig } from '@playwright/test';

export default defineConfig({
	webServer: {
		command: 'npm run build && npm run preview',
		port: 4173
	},

	testDir: 'e2e'
});

================
File: postcss.config.js
================
export default {
	plugins: {
		tailwindcss: {},
		autoprefixer: {}
	}
};

================
File: README.md
================
# sv

Everything you need to build a Svelte project, powered by [`sv`](https://github.com/sveltejs/cli).

## Creating a project

If you're seeing this, you've probably already done this step. Congrats!

```bash
# create a new project in the current directory
npx sv create

# create a new project in my-app
npx sv create my-app
```

## Developing

Once you've created a project and installed dependencies with `npm install` (or `pnpm install` or `yarn`), start a development server:

```bash
npm run dev

# or start the server and open the app in a new browser tab
npm run dev -- --open
```

## Building

To create a production version of your app:

```bash
npm run build
```

You can preview the production build with `npm run preview`.

> To deploy your app, you may need to install an [adapter](https://svelte.dev/docs/kit/adapters) for your target environment.

================
File: svelte.config.js
================
import { mdsvex } from 'mdsvex';
import adapter from '@sveltejs/adapter-auto';
import { vitePreprocess } from '@sveltejs/vite-plugin-svelte';

/** @type {import('@sveltejs/kit').Config} */
const config = {
	// Consult https://svelte.dev/docs/kit/integrations
	// for more information about preprocessors
	preprocess: [vitePreprocess(), mdsvex()],

	kit: {
		// adapter-auto only supports some environments, see https://svelte.dev/docs/kit/adapter-auto for a list.
		// If your environment is not supported, or you settled on a specific environment, switch out the adapter.
		// See https://svelte.dev/docs/kit/adapters for more information about adapters.
		adapter: adapter()
	},

	extensions: ['.svelte', '.svx']
};

export default config;

================
File: tailwind.config.ts
================
import { fontFamily } from "tailwindcss/defaultTheme";
import type { Config } from "tailwindcss";

const config: Config = {
	darkMode: ["class"],
	content: ["./src/**/*.{html,js,svelte,ts}"],
	safelist: ["dark"],
	theme: {
		container: {
			center: true,
			padding: "2rem",
			screens: {
				"2xl": "1400px"
			}
		},
		extend: {
			colors: {
				border: "hsl(var(--border) / <alpha-value>)",
				input: "hsl(var(--input) / <alpha-value>)",
				ring: "hsl(var(--ring) / <alpha-value>)",
				background: "hsl(var(--background) / <alpha-value>)",
				foreground: "hsl(var(--foreground) / <alpha-value>)",
				primary: {
					DEFAULT: "hsl(var(--primary) / <alpha-value>)",
					foreground: "hsl(var(--primary-foreground) / <alpha-value>)"
				},
				secondary: {
					DEFAULT: "hsl(var(--secondary) / <alpha-value>)",
					foreground: "hsl(var(--secondary-foreground) / <alpha-value>)"
				},
				destructive: {
					DEFAULT: "hsl(var(--destructive) / <alpha-value>)",
					foreground: "hsl(var(--destructive-foreground) / <alpha-value>)"
				},
				muted: {
					DEFAULT: "hsl(var(--muted) / <alpha-value>)",
					foreground: "hsl(var(--muted-foreground) / <alpha-value>)"
				},
				accent: {
					DEFAULT: "hsl(var(--accent) / <alpha-value>)",
					foreground: "hsl(var(--accent-foreground) / <alpha-value>)"
				},
				popover: {
					DEFAULT: "hsl(var(--popover) / <alpha-value>)",
					foreground: "hsl(var(--popover-foreground) / <alpha-value>)"
				},
				card: {
					DEFAULT: "hsl(var(--card) / <alpha-value>)",
					foreground: "hsl(var(--card-foreground) / <alpha-value>)"
				}
			},
			borderRadius: {
				lg: "var(--radius)",
				md: "calc(var(--radius) - 2px)",
				sm: "calc(var(--radius) - 4px)"
			},
			fontFamily: {
				sans: [...fontFamily.sans]
			}
		}
	},
};

export default config;

================
File: tsconfig.json
================
{
	"extends": "./.svelte-kit/tsconfig.json",
	"compilerOptions": {
		"allowJs": true,
		"checkJs": true,
		"esModuleInterop": true,
		"forceConsistentCasingInFileNames": true,
		"resolveJsonModule": true,
		"skipLibCheck": true,
		"sourceMap": true,
		"strict": true,
		"moduleResolution": "bundler"
	}
	// Path aliases are handled by https://svelte.dev/docs/kit/configuration#alias
	// except $lib which is handled by https://svelte.dev/docs/kit/configuration#files
	//
	// If you want to overwrite includes/excludes, make sure to copy over the relevant includes/excludes
	// from the referenced tsconfig.json - TypeScript does not merge them in
}

================
File: vite.config.ts
================
import { paraglide } from '@inlang/paraglide-sveltekit/vite';
import { defineConfig } from 'vitest/config';
import { sveltekit } from '@sveltejs/kit/vite';

export default defineConfig({
	plugins: [
		sveltekit(),
		paraglide({
			project: './project.inlang',
			outdir: './src/lib/paraglide'
		})
	],

	test: {
		include: ['src/**/*.{test,spec}.{js,ts}']
	}
});
